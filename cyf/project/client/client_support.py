#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 8.0
#  in conjunction with Tcl version 8.6
#    Dec 09, 2024 09:23:30 PM CST  platform: Windows NT
import configparser
import functools
import json
import os
import sys
import threading
import tkinter as tk
import traceback
import webbrowser
from tkinter import filedialog, messagebox
from tkinter.constants import *

import customtkinter
import requests
from openai.types.chat import ChatCompletionUserMessageParam

from cyf.project.client import client


def resource_path(relative_path):
    """ Get absolute path to resource, works for dev and for PyInstaller """
    try:
        # PyInstaller creates a temp folder and stores path in _MEIPASS
        base_path = sys._MEIPASS
    except Exception:
        base_path = os.path.abspath(".")

    return os.path.join(base_path, relative_path)

_debug = True # False to eliminate debug printing from callback functions.
conf = configparser.ConfigParser()
# 针对打包文件获取路径
conf.read(resource_path('conf/conf.ini'), encoding="UTF-8")
upload_prefix = conf["common"]["upload_pre"]
chat_suf = conf["common"]["chat_suf"]
pic_gen_suf = conf["common"]["pic_gen_suf"]
version = conf["common"]["version"]

model_list = {model_name: conf['model'][model_name] for model_name in conf['model']}
server_list = [server_name + "|" + conf['server'][server_name] for server_name in conf['server']]
# 待上传文件地址
file_path = ""
# dialog缓存
dialog_new = True
# 模型类型，同类模型间对话通用且兼容
model_type = ""
# 暂存服务端回传的会话dict，用于构造对话dialog
dialogs = []
dialogsPic = []


def main(*args):
    '''Main entry point for the application.'''
    global root
    root = customtkinter.CTk()
    root.protocol( 'WM_DELETE_WINDOW' , root.destroy)
    # Creates a toplevel widget.
    global _top1, _w1
    _top1 = root
    _w1 = client.Toplevel1(_top1, title=f"陪聊助手V{version}")
    # 下拉框初始化
    _w1.serverCombobox.configure(values=server_list)
    model_descs = list(model_list.keys())
    _w1.modelCombobox.configure(values=model_descs)
    _w1.serverCombobox.set(server_list[0])
    _w1.modelCombobox.set(model_descs[0])
    root.mainloop()

def catch_exceptions(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except Exception as e:
            traceback.print_exc()
            show_err(f"{e}")
    return wrapper

@catch_exceptions
def upload_file_pre():
    start_request_hint()
    threading.Thread(target=upload_file).start()

@catch_exceptions
def upload_file():
    print('talker_support.upload_file')
    global file_path, _w1, host
    file_path = filedialog.askopenfilename()
    if not file_path:
        return
    print(f"已选择文件: {file_path}")
    _w1.speakBox.configure(state="disabled")
    host = _w1.server_select.get().split("|")[1]
    # api执行上传，
    with open(file_path, 'rb') as file:
        files = {'file': file}
        response = requests.post( f"http://{host}{upload_prefix}", files=files)
    result_json = json.loads(response.text)
    if "msg" in result_json:
        print(response)
        show_err("上传失败，爬爬爬:" + result_json["msg"])
        return
    url = f"http://{host}{result_json["content"]}"
    _w1.speakBox.configure(state="normal")
    # 输入框头部插入url
    _w1.speakBox.insert("1.0", url, "file_url")
    # 超链接
    _w1.speakBox.tag_bind('link', '<Button-1>', lambda evt: webbrowser.open(url))
    _w1.speakBox.insert(END, " ")
    finish_request_hint()
    messagebox.showinfo("ojbk", f"您的文件已上传:{file_path}, url:{url}, 注意保密哦")

@catch_exceptions
def send_chat_pre():
    # after用于单独执行请求返回的渲染
    global root, model_type
    send_content = _w1.speakBox.get("1.0", END)
    _w1.result_text.configure(state="normal")
    _w1.result_text.insert(END, "\n提问：" + send_content + "\n")
    _w1.result_text.configure(state="disabled")
    start_request_hint()
    if model_type == "chat":
        target_func = send_chat
    else:
        target_func = send_pic_gen
    threading.Thread(target=target_func, args=(send_content,)).start()

@catch_exceptions
def send_pic_gen(send):
    global _w1, host, dialog_new
    print(f"model: {_w1.model_select.get()}, server:{_w1.server_select.get()}, user:{_w1.user_name.get()}")
    print(f"send pic content: {send}")
    dialogsPic.append({"role": "user", "desc": send})
    send = _w1.speakBox.get("1.0", END)
    host = _w1.server_select.get().split("|")[1]
    # TODO 后续支持图片会话
    data = {"user": _w1.user_name.get(), "model": _w1.model_select.get(), "dialog": send}
    if not dialog_new:
        data["dialog_mode"] = "multi"
    else:
        dialog_new = False
    response = requests.post(f"http://{host}{pic_gen_suf}", data)
    if len(response.text) <= 0:
        show_err("后端无返回，待会再试")
        return
    result_json = json.loads(response.text)
    # 测试图片
    # result_json = {"role": "assistant", "desc": "test——desc", "url": f':4567/download/images/dall-e-3-1734254013.964897-generated_00.png'}
    if "msg" in result_json:
        show_err(result_json["msg"])
        return
    # 结果序列化存到dialog中
    dialogsPic.append(result_json)
    _w1.result_text.configure(state="normal")
    # url + 超链接
    _w1.result_text.insert(END, "回答(请点击url下载)：\n图片简介：" +  dialogsPic[-1]["desc"] + "\n超链接：")
    url = f"http://{host}{dialogsPic[-1]["url"]}"
    _w1.result_text.insert(END, url, "link")
    _w1.result_text.tag_bind("link", "<Button-1>", lambda evt: webbrowser.open(url))

    _w1.result_text.image_create(END)

    _w1.result_text.configure(state="disabled")
    # 删除内容
    finish_request_hint()
    _w1.speakBox.delete("1.0", END)

@catch_exceptions
def send_chat(send):
    # 接口内容组织&请求&返回
    global _w1, host, dialog_new
    print(f"model: {_w1.model_select.get()}, server:{_w1.server_select.get()}, user:{_w1.user_name.get()}")
    print(f"send chat content: {send}")
    # dialogs历史上下文，加上本次的user chat
    send = _w1.speakBox.get("1.0", END)
    dialogs.append(ChatCompletionUserMessageParam(role="user", content=send))
    # host处理
    host = _w1.server_select.get().split("|")[1]
    data = {
        "user": _w1.user_name.get(),
        "model": _w1.model_select.get(),
    }
    if not dialog_new:
        data["dialog_mode"] = "multi"
        data["dialog"] = json.dumps(dialogs)
    else:
        dialog_new = False
        data["dialog"] = send
    response = requests.post(f"http://{host}{chat_suf}", data)
    if len(response.text) <= 0:
        show_err("后端无返回，待会再试")
        return
    result_json = json.loads(response.text)
    # result_json = {"role": "assistant", "content": "mock数据"}
    if "msg" in result_json:
        show_err(result_json["msg"])
        return
    # 结果序列化存到dialog中
    dialogs.append(result_json)
    # TODO 增加图片渲染环节
    _w1.result_text.configure(state="normal")
    _w1.result_text.insert(END, "回答：" + dialogs[-1]["content"] + "\n")
    _w1.result_text.configure(state="disabled")
    # 删除内容
    finish_request_hint()
    _w1.speakBox.delete("1.0", END)

@catch_exceptions
def refresh():
    global _w1, dialogs, dialog_new
    _w1.result_text.configure(state="normal")
    _w1.result_text.delete("1.0", END)
    _w1.result_text.configure(state="disabled")
    dialogs = []
    dialog_new = True
    return

@catch_exceptions
def switch_model_func(*args):
    # 切换模型时根据其类型决定是否清空对话
    global _w1, model_type
    # ctk用了entry实现样式，清空再写入，因此忽略空值情况
    selected_model = _w1.model_select.get()
    if not selected_model:
        return
    if not model_type:
        model_type = model_list[selected_model]
    if model_type != model_list[selected_model]:
        model_type = model_list[selected_model]
        refresh()
    return

@catch_exceptions
def start_request_hint():
    global _w1
    _w1.requestHint.place(relx=0.483, rely=0.778)
    _w1.progress.place(relx=0.543, rely=0.785)
    _w1.progress.start()

@catch_exceptions
def finish_request_hint():
    global _w1
    _w1.requestHint.place_forget()
    _w1.progress.stop()
    _w1.progress.place_forget()


@catch_exceptions
def get_dialog_his():
    global _w1, dialogs
    messagebox.showinfo("晚点支持", "晚点支持")

@catch_exceptions
def check_to_save():
    # TODO 单独给个checkBox，用于记住填写内容，写到_internal/_usermsg内
    return

def show_err(user_err: str):
    finish_request_hint()
    messagebox.showerror("问题", f"报错: {user_err}")


if __name__ == '__main__':
    client.start_up()




